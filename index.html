<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>終極審判：電車難題 — 分叉軌道 Demo</title>
<style>
  :root{ --bg:#0b1020; --panel:#0f1630; --line:#1f2a55; --fg:#e6edf3; --muted:#9aa7bd; --card:#17213f; --accent:#5bd1ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  .wrap{min-height:100%;display:grid;grid-template-rows:auto 1fr}
  header{padding:12px 16px;display:flex;align-items:center;gap:12px;border-bottom:1px solid var(--line)}
  h1{font-size:18px;margin:0}
  .btn{cursor:pointer;border:1px solid #2a355f;background:#121a36;color:var(--fg);padding:8px 12px;border-radius:10px}
  .btn[disabled]{opacity:.5;cursor:not-allowed}

  .statusbar{display:flex;gap:10px;align-items:center;margin-left:auto;flex-wrap:wrap}
  .statusItem{font-size:20px;font-weight:900;padding:8px 14px;border-radius:14px;color:#fff}
  .statusItem.player{background:#20305f}
  .statusItem.phase{background:#22532a}

  .board{display:grid;grid-template-columns:1fr 420px;gap:16px;padding:16px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:16px;padding:12px}

  .stage{position:relative;background:#0d1533 center/cover no-repeat;border:1px solid var(--line);border-radius:16px;overflow:hidden;min-height:560px;transition:background-image .25s ease}
  .stage.has-bg{background-image:url('assets/track.png');}
  .legend{position:absolute;inset:auto 12px 12px 12px;color:#c3cfe6;font-size:13px;text-shadow:0 1px 0 rgba(0,0,0,.2)}



  /* 取消固定像素定位，改由 JS 按比例设定 top/left/rotate */
  /* .lane.A{top:120px;left:285px;transform:rotate(-8deg)}
     .lane.B{bottom:118px;left:285px;transform:rotate(8deg)} */

  .card{background:var(--card);border:1px solid #2b3a6b;border-radius:10px;padding:6px 8px;min-width:150px;max-width:240px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,.25)}
  .card .type{font-size:12px;color:var(--muted)}
  .card .title{font-weight:700}
  .mods{margin-top:4px;display:flex;flex-direction:column;gap:2px}
  .mod{font-size:11px;background:#1a2548;border:1px solid #33437a;border-radius:8px;padding:2px 6px;color:#cfe4ff;align-self:flex-start}

  .card.destroyed{position:relative;overflow:hidden;animation:tearExit .6s ease forwards;filter:saturate(.7) contrast(1.1)}
  .card.destroyed::before{content:"";position:absolute;inset:-8px;background:url('assets/blood_splash.png') center/cover no-repeat;mix-blend-mode:screen;opacity:.9}
  @keyframes tearExit{0%{transform:rotate(0) scale(1);opacity:1}100%{transform:rotate(14deg) scale(.85);opacity:0}}

  .tabbar{display:flex;gap:8px;margin-top:6px}
  .tab{display:inline-flex;align-items:center;padding:6px 12px;border-radius:10px;border:1px solid #2a355f;background:#111834;cursor:pointer;user-select:none}
  .tab.active{background:#21306a;color:#cfe4ff;box-shadow:0 0 0 2px rgba(91,209,255,.35) inset}
  .hand{display:grid;grid-template-columns:1fr;gap:8px;margin-top:8px}
  .cardBtn{background:#161f3e;border:1px solid #2a355f;border-radius:10px;padding:8px 10px;text-align:left;cursor:pointer;display:flex;justify-content:space-between;align-items:center}
  .cardBtn .tag{font-size:12px;opacity:.9;border:1px solid #2a355f;padding:2px 8px;border-radius:999px}
  .cardBtn.sel{outline:2px solid var(--accent);box-shadow:0 0 0 2px rgba(91,209,255,.25)}
  .log{background:#0e152f;border:1px solid var(--line);border-radius:12px;padding:8px;height:220px;overflow:auto;white-space:pre-wrap;color:#cdd9e5}

  .dialog{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5);z-index:20}
  .dialog .box{background:#0f1630;border:1px solid #2a355f;border-radius:14px;padding:16px;min-width:260px;text-align:center}
  .choiceRow{display:flex;gap:10px;justify-content:center;margin-top:12px}
  .bigChoice{flex:1;padding:10px 14px;border-radius:10px;border:1px solid #30407a;background:#14204a;color:#fff;cursor:pointer;font-size:18px}
  .bigChoice.active{outline:2px solid var(--accent)}

  .trolley{
    position:absolute;width:140px;pointer-events:none;
    filter:drop-shadow(0 6px 12px rgba(0,0,0,.4));
    opacity:1;offset-rotate:auto;offset-distance:0%;z-index:2;
  }
  .trolley.run { animation: trolleyRun var(--trolley-dur, 2400ms) linear forwards; }
  @keyframes trolleyRun { from{offset-distance:0%} to{offset-distance:100%} }

  @media (max-width: 900px){ .board{ grid-template-columns: 1fr; } .stage{ min-height: 60vh; } }
  .force-landscape .board{ grid-template-columns: minmax(0, 1fr) 42vw; gap:10px; }
  .force-landscape .stage{ min-height: calc(100vh - 110px); }
  .force-landscape .side{ height: calc(100vh - 110px); overflow:auto; }


    /* 让两条车道的增长方向一致：从上往下长，别再往上“顶”出屏幕 */
  /* 车道：绝对定位 + 按变量旋转/缩放；统一从左上角生长（向下扩展） */
  .lane{
    position: absolute;           /* ← 必须：让 left/top 生效 */
    display: flex;                /* 卡片一行排布（配合 gap） */
    gap: 12px;
    align-items: flex-start;      /* 统一向下生长，避免 A 往上 B 往下 */
    transform-origin: left top;   /* 旋转/缩放以左上角为原点 */
    /* 提供 transform 变量和默认值（供 setLaneAnchors / refitLane 使用） */
    --lane-angle: 0deg;
    --lane-scale: 1;
    transform: rotate(var(--lane-angle)) scale(var(--lane-scale));
  }

  /* 场上卡片（不影响手牌） */
  .lane .card{
    max-width: 160px;                  /* 限制宽度，避免横向撑出轨道 */
    white-space: normal; 
    word-break: break-word;
    overflow: hidden;                  /* 超出隐藏（由内部区域滚动/折叠处理） */
    font-size: 13px;
    line-height: 1.28;
    position: relative;
  }


  /* 标题最多 3 行，避免标题把卡片拉太高 */
  .lane .card .title{
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    overflow: hidden;
  }

  .lane .card .mod{
    font-size: 11px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    background:#1a2548;
    border:1px solid #33437a;
    color:#cfe4ff;
    border-radius:8px;
    padding:2px 6px;
    align-self:flex-start;
  }

  /* “+N 更多” 折叠按钮外观 */
  .lane .card .mod.more{
    background:#24325f;
    border-color:#3b4e8a;
    cursor:pointer;
  }

  /* （可选）悬浮时显示完整文本气泡 */
  .lane .card:hover::after{
    content: attr(data-full);
    position: absolute;
    left: 0; top: 100%;
    margin-top: 6px;
    background: rgba(0,0,0,.88);
    color:#fff;
    padding:6px 8px;
    border-radius:6px;
    white-space: normal;
    max-width: 280px;
    z-index:10;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
  }

</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>🎚️ 電車難題 — 分叉軌道</h1>
      <div class="statusbar">
        <div class="statusItem player">玩家：<span id="turnPlayer">A</span></div>
        <div class="statusItem phase">階段：<span id="phaseLabel">隨機善已放 / 選善</span></div>
        <button class="btn" id="btnSwitch" disabled>切換玩家</button>
        <button class="btn" id="btnNext" disabled>進入裁決</button>
        <button class="btn" id="btnJudge" disabled>列車長裁決</button>
        <button class="btn" id="btnRotate">横屏显示</button>
        <button class="btn" id="btnReset">重置回合</button>
      </div>
    </header>

    <main class="board">
      <section class="stage has-bg" id="stage">
        <img id="trolley" class="trolley" src="assets/trolley.png" alt="trolley" />
        <div class="lane A" id="laneA" data-side="A"></div>
        <div class="lane B" id="laneB" data-side="B"></div>
        <div class="legend">每條軌道三張：1 隨機善 → 2 玩家選善 → 3 玩家選惡 → 特性 → 裁決。</div>
      </section>

      <aside class="side">
        <div class="panel">
          <div class="tabbar">
            <div class="tab" data-tab="innocent">善良卡</div>
            <div class="tab" data-tab="guilty">邪惡卡</div>
            <div class="tab" data-tab="modifier">特性卡</div>
          </div>
          <div id="hand" class="hand"></div>
        </div>
        <div class="panel">
          <strong>操作記錄</strong>
          <div id="log" class="log"></div>
        </div>
      </aside>
    </main>

    <!-- 特性明细弹窗（复用你已有的样式） -->
  <div class="dialog" id="modsDlg" style="display:none">
    <div class="box" style="background:#0f1630;border:1px solid #2a355f;border-radius:12px;padding:14px;min-width:280px;max-width:420px;color:#fff">
      <div style="font-weight:800;font-size:16px;margin-bottom:8px">特性列表</div>
      <div id="modsList" style="max-height:40vh;overflow:auto;line-height:1.5"></div>
      <div style="text-align:center;margin-top:10px">
        <button class="btn" id="modsClose">關閉</button>
      </div>
    </div>
  </div>


    <div class="dialog" id="judgeDlg">
      <div class="box">
        <div style="font-weight:800;font-size:18px">列車長裁決</div>
        <div style="margin-top:6px;color:#cbd5e1">請選擇要撞的軌道</div>
        <div class="choiceRow">
          <button class="bigChoice" data-side="A">撞 A 軌道</button>
          <button class="bigChoice" data-side="B">撞 B 軌道</button>
        </div>
        <div class="choiceRow"><button class="btn" id="btnConfirmJudge" disabled>確定</button></div>
      </div>
    </div>
  </div>

<script>
/* ------------------- 狀態 ------------------- */
const state = {
  turn:'A',
  hands:{ A:{innocent:[], guilty:[], modifier:[]},
          B:{innocent:[], guilty:[], modifier:[]}, },
  deck:{ innocent:[], guilty:[], modifier:[] },
  _fallbackPools:{ // 作为 JSON 失败时的保底池
    innocent:['天才醫生','幼兒園老師','氣候科學家','圖書館員','志工護士','無辜路人'],
    guilty:['逃犯','邪教頭目','網路詐騙犯','戰犯','惡霸房東'],
    modifier:['其實是你表親','只有一週壽命','其研究將拯救百萬人','暗地裡資助慈善','會發明清潔能源']
  },
  lanes:{A:[],B:[]},
  activeTab:'innocent',
  selected:null,
  phase:'innocent',
  requirements:{A:{inn2:false,g3:false},B:{inn2:false,g3:false}},
  judgePick:null
};


/* ---------- 载入卡池（支持 file->http、重复去重） ---------- */
async function loadPool(kind, url) {
  // kind: 'innocent' | 'guilty' | 'modifier'
  try {
    const resp = await fetch(url, { cache: 'no-store' });
    if (!resp.ok) throw new Error(resp.status);
    const data = await resp.json();
    let list = Array.isArray(data) ? data : (Array.isArray(data[kind]) ? data[kind] : []);
    list = list.map(s => (s||'').toString().replace(/\s+/g,' ').trim()).filter(Boolean);
    const seen = new Set(); list = list.filter(s => !seen.has(s) && seen.add(s));
    return list;
  } catch (e) {
    log(`載入 ${kind} 失敗（${e.message}），使用內建備用卡池`);
    return state._fallbackPools[kind].slice(); // 备援：你代码里原本写死的几张
  }
}

/* ---------- 洗牌 / 抽牌 ---------- */
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
function drawN(deck, n){ const out=[]; while(n-- >0 && deck.length){ out.push(deck.shift()); } return out; }

/* ---------- 建牌库 & 发起手（每回合） ---------- */
async function buildDecksAndDeal() {
  // 1) 从 JSON 取卡池（或缓存）
  const [inn, gui, mod] = await Promise.all([
    loadPool('innocent','./assets/cards/innocent_cards.json'),
    loadPool('guilty','./assets/cards/guilty_cards.json'),
    loadPool('modifier','./assets/cards/modifier_cards.json')
  ]);

  // 2) 建立“牌库”并洗牌
  state.deck = {
    innocent: shuffle(inn.slice()),
    guilty:   shuffle(gui.slice()),
    modifier: shuffle(mod.slice())
  };

  // 3) 给两位玩家“起手牌”——建议各自 5 张善/恶/特（你可改数量）
  const HN = { innocent:5, guilty:5, modifier:5 };

  ['A','B'].forEach(p=>{
    state.hands[p].innocent = drawN(state.deck.innocent, HN.innocent);
    state.hands[p].guilty   = drawN(state.deck.guilty,   HN.guilty);
    state.hands[p].modifier = drawN(state.deck.modifier, HN.modifier);
  });

  // 4) 随机善（第 1 张）从“牌库”抽，不动手牌
  ['A','B'].forEach(side=>{
    const top = state.deck.innocent.shift();
    state.lanes[side].push({title:top, type:'innocent', owner:side, mods:[], random:true});
    log(`系統：在軌道 ${side} 自牌庫放置隨機【善】「${top}」（第1張）`);
  });

  // 准备进入“选善（第二张）”
  state.phase='innocent'; state.activeTab='innocent'; state.turn='A';
  updateHeader(); renderAll();
}

const initialHands = JSON.parse(JSON.stringify(state.hands));
const initialDeck  = JSON.parse(JSON.stringify(state.deck));

/* ------------------- DOM ------------------- */
const handEl=document.getElementById('hand');
const laneA=document.getElementById('laneA');
const laneB=document.getElementById('laneB');
const logEl=document.getElementById('log');
const phaseLabel=document.getElementById('phaseLabel');
const btnNext=document.getElementById('btnNext');
const btnJudge=document.getElementById('btnJudge');
const btnSwitch=document.getElementById('btnSwitch');
const btnRotate=document.getElementById('btnRotate');
const turnPlayer=document.getElementById('turnPlayer');
const stageEl=document.getElementById('stage');
const judgeDlgEl=document.getElementById('judgeDlg');
const btnConfirmJudge=document.getElementById('btnConfirmJudge');
const trolley=document.getElementById('trolley');

const other = p => p==='A' ? 'B' : 'A';
const tabLabel = t => t==='innocent'?'善': t==='guilty'?'惡':'特';
const phaseName = p=> p==='innocent'?'選善（第二張）': p==='guilty'?'選惡（第三張）': p==='modifier'?'特性卡': p==='judge'?'裁決':'結束';
function log(m){ logEl.textContent += `${new Date().toLocaleTimeString()} ${m}\n`; logEl.scrollTop = logEl.scrollHeight; }

/* ------------------- 列車路徑（自適應背景尺寸） ------------------- */
function setTrolleyPaths(){
  const W = stageEl.clientWidth;
  const H = stageEl.clientHeight;

  // 起點：左側主幹道中線附近（按背景比例微調）
  const sx = 0.06*W, sy = 0.46*H;

  // 上支路（A）：向右上彎
  const pathA = [
    `M ${sx},${sy}`,
    `C ${0.24*W},${0.42*H} ${0.52*W},${0.32*H} ${0.90*W},${0.22*H}`,
    `L ${0.98*W},${0.20*H}`
  ].join(' ');

  // 下支路（B）：向右下彎
  const pathB = [
    `M ${sx},${sy}`,
    `C ${0.24*W},${0.50*H} ${0.52*W},${0.62*H} ${0.90*W},${0.78*H}`,
    `L ${0.98*W},${0.80*H}`
  ].join(' ');

  stageEl.dataset.pathA = pathA;
  stageEl.dataset.pathB = pathB;

  // 初始可見：賦予 offset-path 並回到起點
  trolley.style.offsetPath = `path('${pathA}')`;
  trolley.style.offsetDistance = '0%';
  trolley.classList.remove('run');
}

// 载入特性卡（从 JSON 文件）
async function loadModifierFromJSON(url = 'assets/cards/modifier_cards.json') {
  try {
    const resp = await fetch(url, { cache: 'no-store' });
    if (!resp.ok) throw new Error(`載入失敗：${resp.status}`);
    const data = await resp.json();

    // 兼容：既支持 { modifier: [...] }，也支持顶层就是数组
    let list = Array.isArray(data) ? data : (Array.isArray(data.modifier) ? data.modifier : []);

    // 轻度清洗：去前后空白、合并多空格、去掉空项与重复
    list = list
      .map(s => (s || '').toString().replace(/\s+/g, ' ').trim())
      .filter(s => s.length >= 2);

    const seen = new Set();
    list = list.filter(s => !seen.has(s) && seen.add(s));

    // 覆盖“牌库”的特性卡（不改动玩家手牌）
    state.deck.modifier = list.slice();
    log(`已載入特性卡：${state.deck.modifier.length} 張`);
  } catch (err) {
    log(`載入特性卡失敗：${err.message}（使用內建備用卡池）`);
    // 失败时保留你原来写在 state.deck.modifier 里的内建数据
  }
}


/* ------------------- 相對定位兩條車道（關鍵新增） ------------------- */
function setLaneAnchors(){
  const W = stageEl.clientWidth;
  const H = stageEl.clientHeight;
  // 這組比例針對你的分叉背景調過：1920×1080/1366×768/手機都貼軌
  const A = { x: 0.30 * W, y: 0.19 * H, angle: -14 }; // 上支路
  const B = { x: 0.30 * W, y: 0.72 * H, angle:  14 }; // 下支路

  laneA.style.left = `${A.x}px`;
  laneA.style.top  = `${A.y}px`;
  laneA.style.setProperty('--lane-angle', `${A.angle}deg`);

  laneB.style.left = `${B.x}px`;
  laneB.style.top  = `${B.y}px`;
  laneB.style.setProperty('--lane-angle', `${B.angle}deg`);
}

/* ------------------- 初始化：每邊隨機善（來自牌庫） ------------------- */
function autoPlaceRandomInnocent(){
  ['A','B'].forEach(side=>{
    const pool = state.deck.innocent;
    const idx = Math.floor(Math.random()*pool.length);
    const title = pool.splice(idx,1)[0];
    state.lanes[side].push({title, type:'innocent', owner:side, mods:[], random:true});
    log(`系統：在軌道 ${side} 自牌庫放置隨機【善】「${title}」（第1張）`);
  });
  state.phase='innocent'; state.activeTab='innocent'; state.turn='A';
  updateHeader(); renderAll();
}

/* ------------------- 手牌/場面渲染 ------------------- */
function renderHand(){
  handEl.innerHTML='';
  const me = state.turn; const list = state.hands[me][state.activeTab];
  if(!list.length){ const d=document.createElement('div'); d.style.color='#9aa7bd'; d.textContent='（無卡）'; handEl.appendChild(d); return; }
  list.forEach((title,i)=>{
    const btn=document.createElement('div'); btn.className='cardBtn';
    if(state.selected && state.selected.from===me && state.selected.type==='modifier' && state.selected.index===i) btn.classList.add('sel');
    btn.innerHTML = `<strong>${title}</strong><span class="tag">${tabLabel(state.activeTab)}</span>`;
    btn.onclick = ()=>{
      if(state.activeTab==='modifier' && state.phase==='modifier'){
        const already = state.selected && state.selected.from===me && state.selected.type==='modifier' && state.selected.index===i;
        state.selected = already ? null : {type:'modifier', title, from:me, index:i};
        renderHand(); if(state.selected) log(`選中特性卡：${title}，請點場上目標卡`);
      }else{
        playCard({type:state.activeTab,title,from:me,index:i});
      }
    };
    handEl.appendChild(btn);
  });
}

function renderLanes(){
  laneA.innerHTML=''; laneB.innerHTML='';
  state.lanes.A.forEach((c,i)=>laneA.appendChild(renderCardEl('A',i,c)));
  state.lanes.B.forEach((c,i)=>laneB.appendChild(renderCardEl('B',i,c)));
  // ← 渲染完再适配两条轨道的缩放
  refitLane(laneA);
  refitLane(laneB);
}


function refitLane(lane){
  // 允许的最大宽度：舞台宽度的 38%（你可调到 35%/40%）
  const allow = stageEl.clientWidth * 0.38;
  // 先还原 1 倍，测量实际宽度
  lane.style.setProperty('--lane-scale', 1);
  // 用 scrollWidth 估算当前排布宽度（包含换行）
  const w = lane.scrollWidth;
  // 超出则缩小，但不小于 0.7
  const scale = w > allow ? Math.max(0.7, allow / w) : 1;
  lane.style.setProperty('--lane-scale', scale.toFixed(3));
}

function renderCardEl(side, idx, card){
  const wrap=document.createElement('div'); 
  wrap.className='card';
  wrap.dataset.full = card.title;  // 悬浮提示完整标题

  const pos=idx+1;
  const meta=document.createElement('div');
  meta.className='type';
  meta.textContent = `${card.type==='innocent'?'善良':'邪惡'}・${card.owner}・第${pos}張`;

  const titleEl=document.createElement('div');
  titleEl.className='title';
  titleEl.textContent = card.title;

  const mods=document.createElement('div'); 
  mods.className='mods';

  // —— 折叠显示特性：最多展示 3 个，其余收起为 “+N 更多”
  const MAX_SHOW = 3;
  const total = card.mods.length;
  const toShow = card.mods.slice(0, MAX_SHOW);
  toShow.forEach(m=>{
    const d=document.createElement('div'); 
    d.className='mod'; 
    d.textContent=m.title; 
    mods.appendChild(d);
  });
  if (total > MAX_SHOW){
    const more=document.createElement('div');
    more.className='mod more';
    more.textContent = `+${total - MAX_SHOW} 更多`;
    more.title = '點擊查看全部特性';
    more.addEventListener('click', ()=>{
      openModsDialog(card);
    });
    mods.appendChild(more);
  }

  wrap.appendChild(meta);
  wrap.appendChild(titleEl);
  wrap.appendChild(mods);

  if(state.phase==='modifier'){
    wrap.addEventListener('click',(ev)=>{
      // 避免点到 “+N 更多” 触发叠特性
      if (ev.target && ev.target.classList.contains('more')) return;
      if(!(state.selected && state.selected.type==='modifier')) return;
      const s=state.selected; 
      card.mods.push({title:s.title,owner:s.from});
      state.hands[s.from].modifier.splice(s.index,1); 
      state.selected=null; 
      renderAll();
      log(`在「${card.title}」上疊加特性：${card.mods.slice(-1)[0].title}`);
    }, true);
  }
  return wrap;
}



/* ------------------- 出牌 & 階段推進 ------------------- */
function playCard(sel){
  if(!sel) return; const me=state.turn;
  if(state.phase==='innocent' && sel.type!=='innocent'){ log('當前需要【善良卡】'); return; }
  if(state.phase==='guilty'   && sel.type!=='guilty'){   log('當前需要【邪惡卡】'); return; }

  let side=null;
  if(state.phase==='innocent'){ side=me;          state.requirements[me].inn2=true; }
  if(state.phase==='guilty'){   side=other(me);   state.requirements[me].g3=true;  }

  const card={title:sel.title,type:sel.type,owner:me,mods:[]};
  state.lanes[side].push(card);
  state.hands[sel.from][sel.type].splice(sel.index,1);

  renderAll();
  log(`玩家 ${me} 在軌道 ${side} 放置第${state.phase==='innocent'?2:3}張【${tabLabel(sel.type)}】「${sel.title}」`);

  // 換手（直到對手也完成本階段要求）
  if(state.phase==='innocent'){ if(!state.requirements[other(me)].inn2) state.turn=other(me); }
  else if(state.phase==='guilty'){ if(!state.requirements[other(me)].g3) state.turn=other(me); }

  // 推進階段
  if(state.phase==='innocent' && state.requirements.A.inn2 && state.requirements.B.inn2){
    state.phase='guilty'; state.turn='A'; state.activeTab='guilty'; updateHeader(); renderAll(); log('已進入【選惡（第三張）】階段');
  }else if(state.phase==='guilty' && state.requirements.A.g3 && state.requirements.B.g3){
    state.phase='modifier'; state.turn='A'; state.activeTab='modifier';

    // ★ 每回合进入特性阶段时，给双方重新抽本回合可选的特性（各 3 张，可改数量）
    ['A','B'].forEach(p=>{
      // 先把上回合残留的特性手牌清掉（避免越攒越多）
      state.hands[p].modifier = [];
      state.hands[p].modifier = drawN(state.deck.modifier, 5);
    });

    updateHeader(); renderAll(); log('已進入【特性】階段，完成後點「進入裁決」');
  }
}

/* ------------------- 裁決 → 對話框 + 列車行駛 ------------------- */
btnNext.onclick = ()=>{ if(state.phase==='modifier'){ state.phase='judge'; updateHeader(); openJudgeDialog(); } };
btnJudge.onclick= ()=>{ if(state.phase==='judge')   openJudgeDialog(); };

function openJudgeDialog(){ state.judgePick=null; btnConfirmJudge.disabled=true; judgeDlgEl.style.display='flex'; }

document.querySelectorAll('.bigChoice').forEach(b=>{
  b.addEventListener('click',()=>{
    document.querySelectorAll('.bigChoice').forEach(x=>x.classList.remove('active'));
    b.classList.add('active'); state.judgePick=b.dataset.side; btnConfirmJudge.disabled=false;
  });
});
btnConfirmJudge.addEventListener('click',()=>{
  if(!state.judgePick) return; judgeDlgEl.style.display='none';
  runTrolley(state.judgePick);
});

function openModsDialog(card){
  const dlg = document.getElementById('modsDlg');
  const list = document.getElementById('modsList');
  list.innerHTML = card.mods.length
    ? card.mods.map((m,i)=> `<div>${i+1}. ${m.title}</div>`).join('')
    : '<div style="color:#9aa7bd">（沒有特性）</div>';
  dlg.style.display='flex';
}
document.getElementById('modsClose').onclick = ()=>{ 
  document.getElementById('modsDlg').style.display='none';
};


function runTrolley(side){
  log(`列車長裁決：撞 ${side} 軌道`);

  // 選擇路徑並復位到起點
  const p = side==='A' ? stageEl.dataset.pathA : stageEl.dataset.pathB;
  trolley.style.offsetPath = `path('${p}')`;
  trolley.style.offsetDistance = '0%';

  // 觸發運行動畫
  trolley.style.setProperty('--trolley-dur','2400ms');
  trolley.classList.remove('run'); void trolley.offsetWidth; // 重新計算
  trolley.classList.add('run');

  // 碾卡：按卡數均分時間點，逐張觸發 destroyed
  const laneEl = side==='A' ? laneA : laneB;
  const cards = [...laneEl.querySelectorAll('.card')];
  const dur = 2400;
  const step = cards.length ? Math.floor(dur/cards.length) : 600;
  cards.forEach((el,i)=> setTimeout(()=> el.classList.add('destroyed'), i*step));

  const onEnd = ()=>{
    stageEl.style.backgroundImage = "url('assets/track_blood.png')";
    trolley.classList.remove('run');
    state.phase='end'; updateHeader();
    trolley.removeEventListener('animationend', onEnd);
  };
  trolley.addEventListener('animationend', onEnd);
}

/* ------------------- Header/Tabs/按鈕 ------------------- */
function phaseText(){ return state.phase==='innocent' ? '隨機善已放 / 選善' : phaseName(state.phase); }
function updateHeader(){
  turnPlayer.textContent=state.turn;
  phaseLabel.textContent=phaseText();
  btnNext.disabled   = state.phase!=='modifier';
  btnJudge.disabled  = state.phase!=='judge';
  btnSwitch.disabled = state.phase!=='modifier';
  btnSwitch.style.opacity = btnSwitch.disabled ? .5 : 1;
  document.querySelectorAll('.tab').forEach(el=>{
    const should = (state.phase==='innocent' && el.dataset.tab==='innocent')
                || (state.phase==='guilty'   && el.dataset.tab==='guilty')
                || (state.phase==='modifier' && el.dataset.tab==='modifier');
    el.classList.toggle('active', should);
    el.style.opacity = should?1:.45;
    el.style.pointerEvents = should?'auto':'none';
  });
  state.activeTab = (state.phase==='innocent')?'innocent' : (state.phase==='guilty')?'guilty' : (state.phase==='modifier')?'modifier' : state.activeTab;
}

/* 切換玩家（僅特性階段） */
btnSwitch.onclick = ()=>{
  if(state.phase!=='modifier') return;
  state.turn = other(state.turn);
  log(`切換到玩家 ${state.turn} 進行特性操作`);
  updateHeader(); renderHand();
};

/* 重置回合（新版：清場 → 重建牌庫並發牌） */
document.getElementById('btnReset').onclick = async ()=>{
  // 1) 清場與狀態
  state.turn = 'A';
  state.lanes = { A: [], B: [] };
  state.hands = { A:{innocent:[],guilty:[],modifier:[]},
                  B:{innocent:[],guilty:[],modifier:[]} };
  state.deck  = { innocent:[], guilty:[], modifier:[] };
  state.activeTab = 'innocent';
  state.selected  = null;
  state.phase     = 'innocent';
  state.requirements = { A:{inn2:false,g3:false}, B:{inn2:false,g3:false} };
  state.judgePick = null;

  // 2) UI 復位
  stageEl.style.backgroundImage = "url('assets/track.png')";
  trolley.style.opacity = 1;
  trolley.classList.remove('run');
  setTrolleyPaths();   // 重新設置小車路徑
  setLaneAnchors();    // 重算兩條擺卡車道
  renderAll();
  log('已重置：重新洗牌並發牌，稍候放置隨機善…');

  // 3) 重新建牌庫並發牌（含：為 A/B 放置第 1 張隨機善）
  await buildDecksAndDeal();

  // buildDecksAndDeal() 內部會：載入三類 JSON → 洗牌 → 發起手
  // → A/B 各自場上放第 1 張「隨機善」→ 設定 phase='innocent'
  // 所以這裡不需要再呼叫 autoPlaceRandomInnocent()
};


/* Tabs：僅當前階段可點，用來刷新手牌 */
document.querySelectorAll('.tab').forEach(t=>{
  t.addEventListener('click',()=>{ if(!t.classList.contains('active')) return; state.activeTab=t.dataset.tab; renderHand(); });
});

/* 橫屏顯示（不旋轉內容，僅強制兩列佈局） */
btnRotate.addEventListener('click', ()=>{
  const root = document.documentElement;
  const toggled = !root.classList.contains('force-landscape');
  root.classList.toggle('force-landscape', toggled);
  btnRotate.textContent = toggled ? '还原竖屏' : '横屏显示';
  setTimeout(()=>{ setTrolleyPaths(); setLaneAnchors(); refitLane(laneA); refitLane(laneB); }, 60);
});

/* 入口：先設置路徑/車道→渲染→自動隨機善 */
function renderAll(){ renderLanes(); renderHand(); updateHeader(); }
window.addEventListener('load', async ()=>{
  setTrolleyPaths();
  setLaneAnchors();
  await buildDecksAndDeal();   // ← 先加载三类 JSON + 洗牌 + 发牌 + 放随机善
  renderAll();
});


window.addEventListener('resize', ()=>{ setTrolleyPaths(); setLaneAnchors(); refitLane(laneA); refitLane(laneB); });



</script>
</body>
</html>
